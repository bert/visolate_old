# Vona's super-ninja makefile
#
# *** DO NOT EDIT THIS FILE EXCEPT IN THE PROJECT HOME DIRECTORY ***
#
# This makefile is auto-generated by "make makefiles" in the parent package
#
# You can (and should) edit makefile.project, which is included below, to
# specify project-specific settings
#
# You can edit makefile.package, which is included below, to specify
# package-specific targets and variables
#
# Copyright (C) 2004 Marsette A. Vona, III
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc., 59
# Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# $Id: makefile 15 2008-01-23 21:56:45Z vona $

# Relative path to the directory containing the root package for the project.
# For makefile in every directory other than $(PROJECT_HOME) this is
# automatically set by "make makefiles"
PROJECT_HOME = ../.

-include $(PROJECT_HOME)/makefile.project

ifndef BASE_PACKAGE
BASE_PACKAGE := $(notdir $(shell $(CD) $(PROJECT_HOME) && pwd))
endif

ifndef APPNAME
APPNAME := $(BASE_PACKAGE)
endif

# The (full) name of this package.  For makefile in every directory other than
# $(PROJECT_HOME) this is automatically set by "make makefiles"
PACKAGE = $(BASE_PACKAGE).model

# the default target
default: package

#figure out arch

SYSTEM = $(shell uname -s | tr " " "_")
MACHINE = $(shell uname -m | tr " " "_")
ARCH := $(SYSTEM)_$(MACHINE)

#linux: Linux_i686
#OS X: Darwin_Power_Macintosh
#cygwin: CYGWIN-5.1_NT

# misc macros

# these let $(COMMA) and $(SPACE) be lone arguments to make function calls
COMMA := ,
EMPTY :=
SPACE := $(EMPTY) $(EMPTY)

# whitespace regex
WS = [ \t]*

ifneq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)
# make cd .. follow the Physical directory structure on Unix
CD = cd -P
else
CD = cd
# always use bash on cygwin, sh doesn't have pushd, but bash slows things down
SHELL = `which bash`
endif

# tool finding functions

#locate the target of a symlink
#
#works even if the starting point is not a symlink
locate-target = $(shell f="$(1)"; while [ -L "$$f" ]; do f=`ls -l "$$f" | awk '{print $$NF}'`; done; echo "$$f")

#try hard to find a command 
#
#first arg is command name
#
#second arg is expected directory
#
#if cmd executable in directory, that is returned
#
#else if which knows where the command is, that is returned
#
#else empty string is returned
locate-cmd = $(shell if [ -x "$(2)/$(1)" ]; then echo "$(2)/$(1)"; else cmd="$(shell which "$(1)" 2>/dev/null || true)" && if [ -x "$$cmd" ] ; then echo "$$cmd"; else echo ""; fi; fi)

#get the parent directory name
#
#better than the make builtin function because this also works on a directory
dirname = $(shell if [ "$(1)"x != x -a -e "$(1)" ] ; then dirname "$(1)"; else echo ""; fi)

#default a dir
#
#first arg is the desired dir
#
#second is the default dir
#
#returns first arg iff it's a directory, else second arg
default-dir = $(shell if [ ! -d "$(1)" ]; then echo "$(2)"; else echo "$(1)"; fi)

# find tool directories

ifndef TOOLS_HOME
TOOLS_HOME := $(call default-dir,$(PROJECT_TOOLS_HOME),/usr)
endif

BIN := $(call default-dir,$(TOOLS_HOME)/bin/$(ARCH),/usr/bin)
SCRIPTS := $(call default-dir,$(TOOLS_HOME)/scripts,$(BIN))

JDK_BASE := $(TOOLS_HOME)/java/$(ARCH)
JDK_VERSION := newest
JDK_HOME := $(call dirname,$(call dirname,$(call locate-target,$(call locate-cmd,javac,$(JDK_BASE)/$(JDK_VERSION)/bin))))
JDK_EXT := $(JDK_HOME)/jre/lib/ext

ifeq ($(SYSTEM),Darwin)
JDK_EXT := /Library/Java/Extensions
endif

TOOLS_EXT := $(TOOLS_HOME)/java/indep/lib

# find pure java extension jars in the tools java/indep/lib dir if present, else in jre/lib/ext
# NOTE the classes will come in on different classloaders in the two cases, which can lead to subtle CNFEs
EXT_DIR := $(call default-dir,$(TOOLS_EXT),$(JDK_EXT))

# JDK executables
JAVAC := $(call locate-cmd,javac,$(JDK_HOME)/bin)
JAVA := $(call locate-cmd,java,$(JDK_HOME)/bin)
JAVADOC := $(call locate-cmd,javadoc,$(JDK_HOME)/bin)
JAR := $(call locate-cmd,jar,$(JDK_HOME)/bin)
KEYTOOL := $(call locate-cmd,keytool,$(JDK_HOME)/bin)
JARSIGNER := $(call locate-cmd,jarsigner,$(JDK_HOME)/bin)
RMIC := $(call locate-cmd,rmic,$(JDK_HOME)/bin)

#other executables
JAVACC := $(call locate-cmd,javacc,$(BIN))
RSYNC := $(call locate-cmd,rsync,$(BIN))
WWWIMAGESIZE := $(call locate-cmd,wwwimagesize,$(SCRIPTS))

# CompileServer stuff

# the CompileServer binary directory
CS_BIN := $(call dirname,$(call locate-target,$(call locate-cmd,javac_submit,$(BIN))))

# the CompileServer scripts directory
CS_SCRIPTS := $(call dirname,$(call locate-target,$(call locate-cmd,CompileServer-submit,$(SCRIPTS))))

# define NO_COMPILE_SERVER to disable compile server 
ifndef NO_COMPILE_SERVER

CS_ENSURE := $(call locate-cmd,CompileServer-ensure-running,$(CS_SCRIPTS))
CS_SUBMIT := $(call locate-cmd,CompileServer-submit,$(CS_SCRIPTS))

ifdef CS_ENSURE

ifeq ($(findstring OK,$(shell $(CS_ENSURE) nostart)),OK)

ifdef CS_SUBMIT

#ok CompileServer is all good!
JAVAC := $(CS_SUBMIT)
USING_COMPILE_SERVER := 1

endif

endif #OK

endif #CS_ENSURE

endif #NO_COMPILE_SERVER

# rmi stuff

# generate commands to run RMIWrap
#
# first arg is the (simple) name of the API interface
#
# second arg is the (simple) name of the implementation class
run-rmiwrap = if [ ! -f $(1)Remote.java -o ! -f $(2)Server.java -o ! -f $(2)Client.java -o \( $(1).java -nt $(1)Remote.java \) -o \( $(2).java -nt $(2)Client.java \) -o \( $(2).java -nt $(2)Server.java \) ]; then $(JAVA) $(RUN_JAVA_FLAGS) vona.rmi.rmiwrap.RMIWrap $(PACKAGE).$(1) $(PACKAGE).$(2) && $(JAVAC) $(JAVAC_FLAGS) *.java; fi

# generate commands to run rmic
#
# first arg is the (simple) name of the remote class for which to generate a
# stub
RMIC_JRMP_VERSION = 1.1
run-rmic = if [ ! -f $(1)_Stub.class -o $(1).class -nt $(1)_Stub.class ]; then $(RMIC) -v$(RMIC_JRMP_VERSION) -d $(PROJECT_HOME)/.. $(CLASSPATH_FLAG) $(PACKAGE).$(1); fi

# rsync stuff

# flags for rsync
#
# excludes the usual suspects
RSYNC_FLAGS := -rv --progress $(DBG) --copy-links --exclude "**~" --exclude ".\#**" --exclude CVS --exclude .svn --exclude "*.tmp"

# rsync first arg to second arg, with cvs exclude
rsync = $(RSYNC) $(RSYNC_FLAGS) --cvs-exclude $(1) $(2)

# rsync a subproject
#
# first arg is filename extension to include (starting with ".", or empty for
# all)
#
# second arg is the name of a subproject (i.e. the name of the base package of
# the subproject).  If it ends in "." then it is copied non-recursively, else
# it is copied recursively.
#
# third arg is rsync dest, if not absolute then relative to $(PROJECT_HOME)/..
rsync-subproject = pushd $(PROJECT_HOME)/.. && $(RSYNC) $(RSYNC_FLAGS) --include "*/" --exclude "/$(BASE_PACKAGE)/$(JAVADOC_DIR_NAME)/**" --include $(if $(filter ".","$(suffix $(2))"),"/$(call package-to-path,$(basename $(2)))/*$(1)","/$(call package-to-path,$(2))/**$(1)") --exclude "*" $(BASE_PACKAGE) $(3) && popd

# this should have dynamic binding so that makefile.package can override
# JARFILE
JAR_DIR = .$(JARFILE).tmp

# make a jar
#
# does not include hidden files (any file with name beginning ".")
#
# arg 1: "true" to include javadoc tree, "false" otherwise
# arg 2: the list of external jars (none if empty)
# arg 3: the name of the jarfile
# arg 4: the list of filename extensions to include (each beginning with ".", empty to include all)
# arg 5: list of extra files to include (pathnames relative to parent of base package)
# arg 6: includes only files in these subproject packages
make-jar = \
	$(RM) $(3) && \
	$(RM) -r $(JAR_DIR) && \
	mkdir $(JAR_DIR) && \
	if [ $(1) ] && [ -d "$(JAVADOC_DIR)" ]; then $(call rsync,$(JAVADOC_DIR),$(JAR_DIR)); fi && \
	if [ "$(4)foo" == "foo" ]; then \
	$(foreach P,$(6),$(call rsync-subproject,,$(P),$(call package-to-path,$(PACKAGE))/$(JAR_DIR)) && ) true; \
	else $(foreach E,$(4),$(foreach P,$(6),$(call rsync-subproject,$(E),$(P),$(call package-to-path,$(PACKAGE))/$(JAR_DIR)) && )) true; fi && \
	$(foreach F,$(addprefix $(EXT_DIR)/,$(2)),cp $(F) $(JAR_DIR) &&) true && \
	$(foreach F,$(5),cp $(addprefix $(PROJECT_HOME)/../,$(F)) $(JAR_DIR)/$(dir $(F)) &&) true && \
	$(CD) $(JAR_DIR) && \
	$(foreach F,$(2),$(JAR) xvf $(F) && rm $(F) &&) true && \
	rm -rf META-INF && \
	if [ "$(4)foo" == "foo" ]; then \
	$(JAR) cvf  $(3) `find . -not -type d -a -not -name ".*"` $(5); \
	else $(JAR) cvf  $(3) `find . -not -type d -a -not -name ".*" -a "(" -false $(foreach E,$(4),-o -name "*$(E)" ) ")"` $(5); fi && \
	if [ -f ../$(JAR_MF) ]; then $(JAR) ufm  $(3) ../$(JAR_MF); fi && \
	if [ -f ../$(JAR_CRT) ]; then $(JARSIGNER) $(3) $(JARKEY); fi && \
	mv $(3) .. && \
	$(CD) .. && \
	rm -rf $(JAR_DIR)


# template file locations
TEMPLATE_DIR = $(PROJECT_HOME)/templates
JAVA_TEMPLATE = $(TEMPLATE_DIR)/Template.java
EXCEPTION_TEMPLATE = $(TEMPLATE_DIR)/Exception.java
PACKAGE_TEMPLATE = $(TEMPLATE_DIR)/package.html
MAKEFILE_PACKAGE_TEMPLATE = $(TEMPLATE_DIR)/makefile.package

template-m4-common =  m4 -P "-DYEAR=`date +%Y`" "-DPACKAGE=$(PACKAGE)"
template-m4-java =  m4 -P "-DYEAR=`date +%Y`" "-DPACKAGE=$(PACKAGE)" "-DCLASS=$(notdir $(basename $(1)))" $(JAVA_TEMPLATE) > $(basename $(1)).java

# compute short package name from fullname
PACKAGE_NAME = $(subst .,,$(suffix .$(PACKAGE)))

# compute project name (root package name) from package fullname
PROJECT = $(firstword $(subst ., ,$(PACKAGE)))

# heap size flag
MEMORY_FLAG = -Xmx$(TOTAL_HEAP_SIZE)

# compute the package path from the package full name
# $(PROJECT_HOME)/../$(PACKAGE_PATH) is a path to this package
PACKAGE_PATH = $(call package-to-path,$(PACKAGE))

# command to run make without generating any extraneous output
MAKE_SILENT = $(MAKE) --silent --no-print-directory 

# is this the project root package?
ifeq ($(PROJECT_HOME),.)
ROOT_PACKAGE = yes
endif

# flag useful for various tools

# put the parent of project home first on the classpath
# that way if there are built checkouts of the source trees for any EXT_JARS
# then we'll pick up those classes directly from there
NINJA_CLASSPATH := $(PROJECT_HOME)/..

ifdef USING_COMPILE_SERVER
NINJA_CLASSPATH := $(shell pwd)/$(NINJA_CLASSPATH)
endif

# now put each EXT_JAR on the classpath, in order, but only if we're finding
# them in an EXT_DIR which is not the JDK installed extensions dir
ifneq ($(EXT_DIR),$(JDK_EXT))
NINJA_CLASSPATH := $(subst $(SPACE),,$(NINJA_CLASSPATH)$(foreach JAR,$(EXT_JARS),:$(EXT_DIR)/$(JAR)))
endif

# next add the JDK tools jar to the classpath
# in particular, for use by CompileServer
NINJA_CLASSPATH := $(NINJA_CLASSPATH):$(JDK_HOME)/lib/tools.jar

# finally append the user's externally defined CLASSPATH, if any
ifdef CLASSPATH
MAKE_CLASSPATH := $(NINJA_CLASSPATH):$(CLASSPATH)
else
#trailing colon breaks java under Windows
MAKE_CLASSPATH := $(NINJA_CLASSPATH)
endif

ifeq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)
MAKE_CLASSPATH := `cygpath -w -p "$(MAKE_CLASSPATH)"`
endif

CLASSPATH_FLAG = -classpath "$(MAKE_CLASSPATH)"

DEPRECATION_FLAG = -deprecation

# source the package-specific makefile
-include makefile.package

# always exclude these subdirs
EXCLUDE_SUBDIRS += . .. CVS .svn

# figure out our subdirs
PACKAGE_SUBDIRS = $(filter-out $(EXCLUDE_SUBDIRS),$(notdir $(shell find . -maxdepth 1 -type d -not -name ".*.tmp" -a -not -name "javadoc-*")))

# always exclude these source files
EXCLUDE_SOURCE +=

# figure out source files
PACKAGE_SOURCE = $(filter-out $(wildcard $(EXCLUDE_SOURCE)),$(wildcard *.java))
PACKAGE_HTML_SOURCE = $(filter-out $(wildcard $(EXCLUDE_SOURCE)),$(wildcard *.phtml *.m4))

# ALL source 
SOURCE = \
	$(wildcard *.java) \
	$(wildcard *.scm) \
	$(wildcard *.c *.cc *.h *.hh) \
	$(wildcard *.mf) \
	$(wildcard *.jj) \
	$(wildcard *.xsd *.xml *.spp) \
	$(wildcard *.txt *.tex *.html *.htm *.css README) \
	$(wildcard *.properties *.conf *.xcf *.gif *.jpg *.png *.bmp *.ico) \
	$(wildcard *.lws *.lwo *.wrl) \
	$(wildcard *.sh *.csh *.bat *.iss) \
	$(wildcard *.phtml *.m4) \
	$(wildcard *.policy) \
	package.html makefile.package

ifdef ROOT_PACKAGE
SOURCE += makefile makefile.project
endif

# compile-time flags
JAVAC_FLAGS += $(DEPRECATION_FLAG) $(CLASSPATH_FLAG) -source $(SOURCE_VERSION) -target $(TARGET_VERSION)  $(JAVAC_OPTIONS)

# runtime flags
RUN_JAVA_FLAGS += $(CLASSPATH_FLAG) $(MEMORY_FLAG) $(WORKAROUND_FLAGS) $(JAVA_OPTIONS) -ea

# javadoc flags
JAVADOC_FLAGS += $(CLASSPATH_FLAG) -source $(JAVADOC_SOURCE_VERSION) -private -use -author -doctitle $(APPNAME) `if [ -e overview.html ]; then echo -overview overview.html; else echo ""; fi`

# subpackage makefiles
SUBPACKAGE_MAKEFILES = $(addsuffix /makefile,$(PACKAGE_SUBDIRS))

# HTML stuff
.SUFFIXES:	.m4 .phtml .html
WWWROOT = $(HOME)/www
html-m4 =  m4 -P "-DBUILD_DATE=`date`" "-DYEAR=`date +%Y`" "-I$(WWWROOT)/include" $(1) > $(2)
html-cpp = gcc -E -P -traditional "-DBUILD_DATE=`date`" "-DYEAR=`date +%Y`" "-I$(WWWROOT)/include" - < $(1) > $(2)

# function to generate a javadoc command line
#
# javadoc will be deposited in $(JAVADOC_DIR)
#
# first arg is list of base packages.  Javadoc will be built for all
# subpackages of the base packages.
javadoc = $(JAVADOC) $(JAVADOC_FLAGS) -d $(JAVADOC_DIR) $(foreach P,$(1), -subpackages $(P))

# function to make a target recursively
# first argument is target to make
# second argument is "true" to continue on fail, "false" to stop on fail
recursively-make = $(foreach DIR,$(PACKAGE_SUBDIRS),[ ! -d $(DIR) ] || pushd $(DIR) > /dev/null && ( $(MAKE) $(1) || $(2) ) && popd > /dev/null && ) true

# function to make something from $(PROJECT_HOME)
make-from-project-home = \
	@echo making $(1) from $(PROJECT_HOME); \
	$(CD) $(PROJECT_HOME) && $(MAKE) $(1)

# function to convert a package name to a path
package-to-path = $(subst .,/,$(1))

# function to extract the package part of a full class name (not including
# the trailing .class)
package-part = \
	$(basename $(1))

# function to extract the class part of a full class name (not including the
# trailing .class)
class-part = \
	$(subst .,,$(suffix $(1)))

# use this target as a prereq to force another target
.PHONY: FORCE
FORCE:

# pattern rules

# initialize a new class file
%.java-template: $(JAVA_TEMPLATE)
	if [ ! -f ./$(basename $@).java ] || [ ! -s ./$(basename $@).java ]; then $(call template-m4-java,$@); else echo ./$(basename $@).java exists and is non-empty, not overwriting; fi

.PHONY: java-templates
java-templates:
	$(foreach F,$(shell find . -maxdepth 1 -size 0 -name "*.java"),$(call template-m4-java,$F); )

# initialize a new Exception class file
%.java-exception-template: $(EXCEPTION_TEMPLATE)
	if [ ! -f ./$(basename $@).java ]; then cp $(EXCEPTION_TEMPLATE) ./$(basename $@).java; else echo ./$(basename $@).java exists, not overwriting; fi

# initialize a new package.html file 
.PHONY: package.html-template
package.html-template: $(PACKAGE_TEMPLATE)
	if [ ! -f package.html ]; then cp $(PACKAGE_TEMPLATE) ./package.html; else echo ./package.html exists, not overwriting; fi

# initialize a new makefile.package file 
.PHONY: makefile.package-template
makefile.package-template: $(MAKEFILE_PACKAGE_TEMPLATE)
	if [ ! -f makefile.package ]; then cp $(MAKEFILE_PACKAGE_TEMPLATE) ./makefile.package; else echo ./makefile.package exists, not overwriting; fi

# make html from m4
%.html: %.m4
	$(call html-m4,$<,$@)
	if [ -x "$(WWWIMAGESIZE)" ]; then $(WWWIMAGESIZE) -MakeBackup no $@; fi

# make html from phtml by sending it through the C pre-processor
%.html: %.phtml
	$(call html-cpp,$<,$@)
	if [ -x "$(WWWIMAGESIZE)" ]; then $(WWWIMAGESIZE) -MakeBackup no $@; fi

# build a .class file from a .java file

ifeq ($(findstring CYGWIN,$(SYSTEM)),CYGWIN)

#fix paths on cygwin. ARGH...

ifdef USING_COMPILE_SERVER
%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) "`cygpath -w "$(addprefix $(shell pwd)/,$<)"`"
else
%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) $<
endif

else

# not on cygwin.  Phew.

%.class: %.java
	$(JAVAC) $(JAVAC_FLAGS) $<

endif

# build Java source files from a .jj grammar file
%.java: %.jj
	$(JAVACC) $<

# run a class in a specific package
$(PROJECT).%.run: $(if BUILD_BEFORE_RUN,$(PROJECT).%.class,)
	$(JAVA) $(RUN_JAVA_FLAGS) $(basename $@)

# run a class in the current package with a main() function directly
%.run: $(if BUILD_BEFORE_RUN,%.class,)
	$(JAVA) $(RUN_JAVA_FLAGS) $(PACKAGE).$(basename $@) 

# run a class in appletviewer (specify html filename without path or extension)
%.appletviewer:
	$(JDK_HOME)/bin/appletviewer $(basename $@).html

# build a class in a specific package
$(PROJECT).%.class:
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(call package-part,$(basename $@))) && $(MAKE) $(call class-part,$(basename $@)).class

# build a specific package
$(PROJECT).%.package-make:
	@echo making package $@
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(basename $@)) && $(MAKE) package

# recursive build of the base package is a project build
# note the semicolon which makes this an "empty command"!!
# without it the %.recursive pattern would get called after this runs
# resulting in an infinite loop!!
$(PROJECT).package-make.recursive: project ;

# build a specific package and all descendant packages
$(PROJECT).%.package-make.recursive:
	@echo making package $@ and all descendant packages
	$(CD) $(PROJECT_HOME)/../$(call package-to-path,$(basename $(basename $@))) && $(MAKE) package.recursive

# trick make into building the base package when asked
# if we don't do this then a spurious implicit rule gets invoked because the
# base package has no .suffix
$(PROJECT).package-make:
	@echo making base package
	$(CD) $(PROJECT_HOME) && $(MAKE) package

# recursively make something
%.recursive:
#	@echo recursively making $(basename $@)
	$(MAKE) $(basename $@)
	$(call recursively-make,$@,true)

# fun targets

.PHONY: love
love:
	@echo not war

.PHONY: pull-plug
pull-plug:
	@echo My mind is going.  I can FEEL it.

.PHONY: open-the-pod-bay-doors-hal
open-the-pod-bay-doors-hal:
	@echo I\'m sorry `finger \`whoami\` | sed -e '2,$$d' -e '1s/.*:.*:[ ]*\([^ ]*\).*/\1/'`, I\'m afraid I can\'t do that.

# global targets

# utility targets

.PHONY: show-exclude-source
show-exclude-source:
	@echo $(EXCLUDE_SOURCE)

.PHONY: show-exclude-subdirs
show-exclude-subdirs:
	@echo $(EXCLUDE_SUBDIRS)

.PHONY: show-package
show-package:
	@echo $(PACKAGE)

.PHONY: show-project-home
show-project-home:
	@echo $(PROJECT_HOME)

.PHONY: show-classpath
show-classpath:
	@echo $(MAKE_CLASSPATH)

.PHONY: show-jdk-home
show-jdk-home:
	@echo $(JDK_HOME)

.PHONY: show-jdk-ext
show-jdk-ext:
	@echo $(JDK_EXT)

.PHONY: show-tools-ext
show-tools-ext:
	@echo $(TOOLS_EXT)

.PHONY: show-ext-dir
show-ext-dir:
	@echo $(EXT_DIR)

.PHONY: show-java
show-java:
	@echo $(JAVA)

.PHONY: show-run-java-flags
show-run-java-flags:
	@echo $(RUN_JAVA_FLAGS)

.PHONY: show-run-java-with-flags
show-run-java-with-flags:
	@echo $(JAVA) $(RUN_JAVA_FLAGS)

.PHONY: show-run-java-with-flags-and-package
show-run-java-with-flags-and-package:
	@echo $(JAVA) $(RUN_JAVA_FLAGS) $(PACKAGE)

.PHONY: show-bin
show-bin:
	@echo $(BIN)

.PHONY: show-cs-bin
show-cs-bin:
	@echo $(CS_BIN)

.PHONY: show-scripts
show-scripts:
	@echo $(SCRIPTS)

.PHONY: show-cs-scripts
show-cs-scripts:
	@echo $(CS_SCRIPTS)

.PHONY: show-settings
show-settings:
	@echo Make settings:
	@echo APPNAME: $(APPNAME)
	@echo BASE_PACKAGE: $(BASE_PACKAGE)
	@echo ARCH: $(ARCH)
	@echo TOOLS_HOME: $(TOOLS_HOME)
	@echo SCRIPTS: $(SCRIPTS)
	@echo CS_SCRIPTS: $(CS_SCRIPTS)
	@echo CS_BIN: $(CS_BIN)
	@echo CS_ENSURE: $(CS_ENSURE)
	@echo CS_SUBMIT: $(CS_SUBMIT)
	@echo JDK_BASE: $(JDK_BASE)
	@echo JDK_HOME: $(JDK_HOME)
	@echo JDK_EXT: $(JDK_EXT)
	@echo TOOLS_EXT: $(TOOLS_EXT)
	@echo EXT_DIR: $(EXT_DIR)
	@echo JDK_VERSION: $(JDK_VERSION)
	@echo SOURCE_VERSION: $(SOURCE_VERSION)
	@echo TARGET_VERSION: $(TARGET_VERSION)
	@echo JAVAC: $(JAVAC)
	@echo JAVA: $(JAVA)
	@echo JAVADOC: $(JAVADOC)
	@echo JAVACC: $(JAVACC)
	@echo JAR: $(JAR)
	@echo NO_COMPILE_SERVER: "$(NO_COMPILE_SERVER)"
	@echo USING_COMPILE_SERVER: "$(USING_COMPILE_SERVER)"
	@echo SHELL: $(SHELL)
	@echo CD: $(CD)
	@echo PROJECT: $(PROJECT)
	@echo PROJECT_HOME: $(PROJECT_HOME)
ifdef ROOT_PACKAGE
	@echo this is the root package
else
	@echo this is not the root package
endif
	@echo PACKAGE: $(PACKAGE)
	@echo PACKAGE_PATH: '$(PACKAGE_PATH)'
	@echo PACKAGE_NAME: $(PACKAGE_NAME)
	@echo EXCLUDE_SUBDIRS: $(EXCLUDE_SUBDIRS)
	@echo PACKAGE_SUBDIRS: $(PACKAGE_SUBDIRS)
	@echo EXCLUDE_SOURCE: $(EXCLUDE_SOURCE)
	@echo PACKAGE_SOURCE: $(PACKAGE_SOURCE)
	@echo PACKAGE_HTML_SOURCE: $(PACKAGE_HTML_SOURCE)
	@echo SOURCE: $(SOURCE)
	@echo SUBPROJECT_PACKAGES: $(SUBPROJECT_PACKAGES)
	@echo JAVAC_FLAGS: '$(JAVAC_FLAGS)'
	@echo JAVADOC_FLAGS: '$(JAVADOC_FLAGS)'
	@echo JAVADOC_DIR: $(JAVADOC_DIR)
	@echo JAR_DIR: $(JAR_DIR)
	@echo JAR_MF: $(JAR_MF)
	@echo JARKEY: $(JARKEY)
	@echo JAR_CRT: $(JAR_CRT)
	@echo EXT_JARS: $(EXT_JARS)
	@echo MAKE_CLASSPATH: '$(MAKE_CLASSPATH)'
	@echo SUBPACKAGE_MAKEFILES: $(SUBPACKAGE_MAKEFILES)
	@echo PUBLISH_DEST: $(PUBLISH_DEST)

# package targets

# make the current package
.PHONY: package
package: $(EXTRA_PACKAGE_DEPS) $(if $(NO_SOURCE_GEN),,package-source-gen) package-javacc-make $(addsuffix .class,$(basename $(PACKAGE_SOURCE))) $(addsuffix .html,$(basename $(PACKAGE_HTML_SOURCE)))
	$(EXTRA_PACKAGE_CMDS)

# make javacc in the current package
.PHONY: packge-javacc-make
package-javacc-make: $(addsuffix .class,$(basename $(wildcard *.jj)))

# make the makefile in the current package
ifndef ROOT_PACKAGE
makefile: $(PROJECT_HOME)/makefile
	@$(CD) .. && $(MAKE) $(PACKAGE_NAME)/makefile
else
makefile: FORCE
endif

.PHONY: clean
clean: $(EXTRA_CLEAN_DEPS)
	@echo removing all .class files in this package 
	$(RM) *.class

.PHONY: c-clean
c-clean:
	@echo removing all .o files in this package 
	$(RM) *.o

.PHONY: javacc-clean
javacc-clean:
	@echo removing javacc-generated files
	$(RM) `ls *.java | xargs grep -l "Generated By:JavaCC"`

.PHONY: rmiwrap-clean
rmiwrap-clean:
	@echo removing RMIWrap-generated files
	$(RM) `ls *.java | xargs grep -l "generated by RMIWrap"`

.PHONY: html-clean
html-clean:
	@echo removing all generated html
	$(RM) $(addsuffix .html,$(basename $(PACKAGE_HTML_SOURCE)))

.PHONY: jar-clean
jar-clean:
	$(RM) $(JARFILE) $(JARFILE_LITE) $(JARFILE_XLITE)

.PHONY: javadoc-clean
javadoc-clean:
	$(RM) -r $(JAVADOC_DIR)

.PHONY: realclean
realclean: $(EXTRA_REALCLEAN_DEPS) clean rmiwrap-clean javacc-clean html-clean jar-clean javadoc-clean
	if [ -f core ]; then $(RM) core; fi

.PHONY: package-javacc-gen
package-javacc-gen: $(addsuffix .java,$(basename $(wildcard *.jj)))

.PHONY: package-source-gen
package-source-gen: package-javacc-gen

# project targets

.PHONY: project-announce
project-announce:
	@echo making project

.PHONY: project
project: project-announce $(if $(NO_SOURCE_GEN),,project-source-gen)
	$(call make-from-project-home,package.recursive)

.PHONY: project-javacc-gen
project-javacc-gen: makefiles
	$(call make-from-project-home,package-javacc-gen.recursive)

.PHONY: project-source-gen
project-source-gen: makefiles
	$(call make-from-project-home,package-source-gen.recursive)

.PHONY: project-javadoc
project-javadoc:
	$(call make-from-project-home,subproject-javadoc)

.PHONY: subproject-javadoc
subproject-javadoc:
	if [ "$(SUBPROJECT_PACKAGES)" ]; then $(call javadoc,$(SUBPROJECT_PACKAGES)); fi

.PHONY: project-clean
project-clean:
	$(call make-from-project-home,clean.recursive)

.PHONY: project-realclean
project-realclean:
	$(call make-from-project-home,realclean.recursive)


$(SUBPACKAGE_MAKEFILES): makefile
	@if [ -e $@ ] && [ `grep -c super-ninja $@ 2> /dev/null ` -eq 0 ]; \
	then echo "$@ exists but is not super-ninja, skipping"; \
	else echo "(re)making $@" && \
	$(RM) $@ && \
	sed \
	-e 's|^$(WS)PROJECT_HOME$(WS)=$(WS)\(.*\)$(WS)|PROJECT_HOME = ../\1|' \
	-e 's/^$(WS)PACKAGE$(WS)=$(WS)\(.*\)$(WS)/PACKAGE = \1.$(subst /,,$(dir $@))/' \
  -e 's/^$(WS)if-root-package$(WS)=.*/if-root-package = $$(2)/' \
  makefile > $@; fi

.PHONY: makefiles
makefiles: $(SUBPACKAGE_MAKEFILES)
	@echo making makefiles
	@$(call recursively-make,makefiles,true)

# make the jar key
.PHONY: keygen
keygen:
	$(JDK_HOME)/bin/keytool -genkey -keyalg rsa -alias $(JARKEY)
	$(JDK_HOME)/bin/keytool -export -alias $(JARKEY) -file $(JAR_CRT)

# make the jar
#
# the jar is built containing all rsync-able files in all
# $(SUBPROJECT_PACKAGES), the subproject javadoc, and the makefile from the
# base package.  Subproject packages ending in "." are copied non-recursively,
# else they are copied recursively.
#
# empty dirs will not be included in the jar
#
# all $(EXT_JARS), if any, are folded into the jarfile
#
# if $(JAR_MF) exists it is used as the jar manifest
#
# if $(JAR_CRT) exist the jar is signed with $(JARKEY)
.PHONY: jar
jar:
	$(call make-jar,true,$(EXT_JARS),$(JARFILE),$(JARFILE_EXTS),$(JAR_EXTRA),$(SUBPROJECT_PACKAGES))

# make the lite jar
#
# same as the "jar" target except uses LITE_SUBPROJECT_PACKAGES, EXT_JARS_LITE,
# JARFILE_LITE_EXTS, JAR_LITE_EXTRA, and never includes the javadoc tree
jar-lite:
	$(call make-jar,false,$(EXT_JARS_LITE),$(JARFILE_LITE),$(JARFILE_LITE_EXTS),$(JAR_LITE_EXTRA),$(LITE_SUBPROJECT_PACKAGES))

# make the xlite jar
#
# same as the "jar-lite" target except uses XLITE_SUBPROJECT_PACKAGES,
# EXT_JARS_XLITE, JARFILE_XLITE_EXTS, and JAR_XLITE_EXTRA
.PHONY: jar-xlite
jar-xlite:
	$(call make-jar,false,$(EXT_JARS_XLITE),$(JARFILE_XLITE),$(JARFILE_XLITE_EXTS),$(JAR_XLITE_EXTRA),$(XLITE_SUBPROJECT_PACKAGES))


# publish to PUBLISH_DEST
#
# rsyncs $(JARFILE) (and $(JARFILE_LITE), and $(JARFILE_XLITE), if any)
# there AND rsync's $(JARFILE_PUBLISH_UNPACK)'s contents there
.PHONY: publish
ifdef PUBLISH_DEST
publish:
	@echo publishing to $(PUBLISH_DEST)
	if [ $(JARFILE_PUBLISH_UNPACK) ]; then \
	mkdir .$(JARFILE_PUBLISH_UNPACK)-unpack.tmp; \
	cd .$(JARFILE_PUBLISH_UNPACK)-unpack.tmp && $(JAR) xvf ../$(JARFILE_PUBLISH_UNPACK) && $(call rsync,*,$(PUBLISH_DEST)); \
	cd .. && rm -rf .$(JARFILE_PUBLISH_UNPACK)-unpack.tmp; \
	fi
	if [ $(JARFILE) -a -f $(JARFILE) ]; then $(call rsync,$(JARFILE),$(PUBLISH_DEST)); fi
	if [ $(JARFILE_LITE) -a -f $(JARFILE_LITE) ]; then $(call rsync,$(JARFILE_LITE),$(PUBLISH_DEST)); fi
	if [ $(JARFILE_XLITE) -a -f $(JARFILE_XLITE) ]; then $(call rsync,$(JARFILE_XLITE),$(PUBLISH_DEST)); fi
	$(EXTRA_PUBLISH_CMDS)
else
publish: $(JARFILE)
	@echo PUBLISH_DEST not set
	$(EXTRA_PUBLISH_CMDS)
endif

# publish to PUBLISH_DEST
#
# rsyncs $(JARFILE_LITE), there
.PHONY: publish-lite
ifdef PUBLISH_DEST
publish-lite: $(JARFILE_LITE)
	@echo publishing to $(PUBLISH_DEST)
	$(call rsync,$(JARFILE_LITE),$(PUBLISH_DEST))
	$(EXTRA_PUBLISH_CMDS)
else
publish-lite: $(JARFILE_LITE)
	@echo PUBLISH_DEST not set
	$(EXTRA_PUBLISH_CMDS)
endif


